import Foundation
import WebKit

/// WebKit-based transcript extractor that uses WKWebView to run YouTube's JavaScript.
///
/// **The POT Token Problem:**
/// YouTube's `captionTracks[].baseUrl` does NOT include the POT token.
/// Fetching baseUrl directly returns 0 bytes (status 200 but empty body).
/// The POT token is generated by YouTube's botguard JavaScript ONLY when
/// the player actually requests captions (e.g., when CC button is clicked).
///
/// **Solution:**
/// 1. Inject XHR/fetch interceptor BEFORE page loads
/// 2. After page loads, click the CC button to trigger caption loading
/// 3. Interceptor captures the real caption URL (which includes `pot=` parameter)
/// 4. Fetch that URL to get actual transcript data
@MainActor
class WebKitTranscriptExtractor: NSObject, WKNavigationDelegate {
    
    private var webView: WKWebView?
    private var continuation: CheckedContinuation<String?, Never>?
    private var videoId: String = ""
    private var hasFinished: Bool = false
    
    /// Extract transcript using WKWebView to execute YouTube's JavaScript
    func extractTranscript(videoId: String) async -> String? {
        self.videoId = videoId
        self.hasFinished = false
        
        print("ðŸ“± WebKit: Starting extraction for \(videoId)")
        
        return await withCheckedContinuation { continuation in
            self.continuation = continuation
            setupWebView()
            loadYouTubePage()
            
            // Safety timeout - if nothing happens in 20 seconds, give up
            Task {
                try? await Task.sleep(nanoseconds: 20_000_000_000)
                self.finishWithResult(nil)
            }
        }
    }
    
    private func setupWebView() {
        let config = WKWebViewConfiguration()
        config.allowsInlineMediaPlayback = true
        config.mediaTypesRequiringUserActionForPlayback = []
        
        // CRITICAL: Inject interceptor BEFORE page loads to capture network requests
        let interceptScript = WKUserScript(
            source: networkInterceptorScript(),
            injectionTime: .atDocumentStart,
            forMainFrameOnly: false
        )
        config.userContentController.addUserScript(interceptScript)
        
        // Handle messages from JS
        config.userContentController.add(LeakAvoider(delegate: self), name: "captionHandler")
        
        webView = WKWebView(frame: .zero, configuration: config)
        webView?.navigationDelegate = self
        
        // Set mobile user agent
        webView?.customUserAgent = "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1"
    }
    
    private func loadYouTubePage() {
        guard let url = URL(string: "https://www.youtube.com/watch?v=\(videoId)") else {
            finishWithResult(nil)
            return
        }
        webView?.load(URLRequest(url: url))
    }
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        print("ðŸ“± WebKit: Page loaded, waiting for player...")
        
        // Wait for player to initialize, then click CC button
        Task {
            try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
            await triggerCaptionLoading()
        }
    }
    
    /// Click the CC button to trigger YouTube's caption request (which will have POT token)
    private func triggerCaptionLoading() async {
        let clickScript = """
        (function() {
            // Enable captions by clicking CC button
            var ccButton = document.querySelector('.ytp-subtitles-button');
            if (ccButton) {
                // Only click if not already enabled
                if (ccButton.getAttribute('aria-pressed') !== 'true') {
                    console.log('WK: Clicking CC button');
                    ccButton.click();
                }
                return 'clicked';
            }
            
            // Alternative: Try settings menu
            var settingsBtn = document.querySelector('.ytp-settings-button');
            if (settingsBtn) {
                console.log('WK: No CC button, trying settings');
                return 'no_cc_button';
            }
            
            return 'no_player';
        })();
        """
        
        webView?.evaluateJavaScript(clickScript) { [weak self] result, error in
            if let result = result as? String {
                print("ðŸ“± WebKit: CC button action: \(result)")
            }
            if let error = error {
                print("ðŸ“± WebKit: CC click error: \(error.localizedDescription)")
            }
        }
        
        // Wait for caption request to be intercepted (the script will send a message)
        // If no caption URL is intercepted within 8 seconds, try alternative extraction
        try? await Task.sleep(nanoseconds: 8_000_000_000)
        
        // If still no result, try extracting from DOM
        if !hasFinished {
            await tryDOMExtraction()
        }
    }
    
    /// Fallback: Try to extract visible caption text from the DOM
    private func tryDOMExtraction() async {
        let domScript = """
        (function() {
            // Try to get caption text from the player's caption container
            var captionWindow = document.querySelector('.ytp-caption-window-container');
            if (captionWindow) {
                var text = captionWindow.innerText;
                if (text && text.length > 0) {
                    return { source: 'dom', text: text };
                }
            }
            
            // Try caption overlay
            var overlay = document.querySelector('.captions-text');
            if (overlay) {
                return { source: 'overlay', text: overlay.innerText };
            }
            
            return { error: 'No captions in DOM' };
        })();
        """
        
        webView?.evaluateJavaScript(domScript) { [weak self] result, error in
            // DOM extraction is usually not sufficient for full transcript
            // Just finish with nil if we get here
            print("ðŸ“± WebKit: DOM extraction attempted")
            self?.finishWithResult(nil)
        }
    }
    
    private func finishWithResult(_ result: String?) {
        guard !hasFinished else { return }
        hasFinished = true
        
        if let cont = continuation {
            continuation = nil
            cont.resume(returning: result)
        }
        cleanup()
    }
    
    private func cleanup() {
        webView?.stopLoading()
        webView?.configuration.userContentController.removeScriptMessageHandler(forName: "captionHandler")
        webView = nil
    }
    
    /// Script injected at document start to intercept ALL network requests.
    /// Captures caption URLs that contain the POT token.
    private func networkInterceptorScript() -> String {
        return """
        (function() {
            console.log('WK: Network interceptor installed');
            
            // Intercept XMLHttpRequest
            var origXHROpen = XMLHttpRequest.prototype.open;
            var origXHRSend = XMLHttpRequest.prototype.send;
            
            XMLHttpRequest.prototype.open = function(method, url) {
                this._url = url;
                return origXHROpen.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function() {
                var xhr = this;
                var url = this._url || '';
                
                // Check if this is a timedtext request with POT token
                if (url.indexOf('timedtext') !== -1 && url.indexOf('v=') !== -1) {
                    console.log('WK: Intercepted timedtext XHR: ' + url.substring(0, 100));
                    
                    // Listen for response
                    xhr.addEventListener('load', function() {
                        if (xhr.responseText && xhr.responseText.length > 100) {
                            console.log('WK: Got caption data via XHR (' + xhr.responseText.length + ' chars)');
                            window.webkit.messageHandlers.captionHandler.postMessage({
                                source: 'xhr',
                                transcript: xhr.responseText
                            });
                        }
                    });
                }
                return origXHRSend.apply(this, arguments);
            };
            
            // Intercept fetch
            var origFetch = window.fetch;
            window.fetch = function(input, init) {
                var url = (typeof input === 'string') ? input : input.url;
                
                if (url && url.indexOf('timedtext') !== -1 && url.indexOf('v=') !== -1) {
                    console.log('WK: Intercepted timedtext fetch: ' + url.substring(0, 100));
                    
                    return origFetch.apply(this, arguments).then(function(response) {
                        // Clone to read body without consuming it
                        var clone = response.clone();
                        clone.text().then(function(text) {
                            if (text && text.length > 100) {
                                console.log('WK: Got caption data via fetch (' + text.length + ' chars)');
                                window.webkit.messageHandlers.captionHandler.postMessage({
                                    source: 'fetch',
                                    transcript: text
                                });
                            }
                        });
                        return response;
                    });
                }
                return origFetch.apply(this, arguments);
            };
        })();
        """
    }
}

// Handle script messages
extension WebKitTranscriptExtractor: WKScriptMessageHandler {
    nonisolated func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        Task { @MainActor in
            guard let body = message.body as? [String: Any] else {
                return
            }
            
            // Got transcript from intercepted request
            if let transcript = body["transcript"] as? String, !transcript.isEmpty {
                let source = body["source"] as? String ?? "unknown"
                print("ðŸ“± WebKit: SUCCESS via \(source) - Got \(transcript.count) chars")
                finishWithResult(parseTranscript(transcript))
                return
            }
            
            if let error = body["error"] as? String {
                print("ðŸ“± WebKit: Error - \(error)")
                // Don't finish yet - let it try other methods
            }
        }
    }
    
    private func parseTranscript(_ jsonString: String) -> String? {
        // Try to parse as JSON3 format
        guard let data = jsonString.data(using: .utf8) else { return nil }
        
        do {
            if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
               let events = json["events"] as? [[String: Any]] {
                var texts: [String] = []
                for event in events {
                    if let segs = event["segs"] as? [[String: Any]] {
                        for seg in segs {
                            if let utf8 = seg["utf8"] as? String {
                                texts.append(utf8)
                            }
                        }
                    }
                }
                let result = texts.joined(separator: " ")
                    .replacingOccurrences(of: "\n", with: " ")
                    .replacingOccurrences(of: "  ", with: " ")
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                return result.isEmpty ? nil : result
            }
        } catch {
            // Not JSON, might be XML or other format - return as-is if it looks like text
            if jsonString.count > 100 && !jsonString.contains("<html") {
                // Try XML parsing
                return parseTranscriptXML(data)
            }
        }
        return nil
    }
    
    private func parseTranscriptXML(_ data: Data) -> String? {
        // Simple XML transcript parsing
        guard let xmlString = String(data: data, encoding: .utf8) else { return nil }
        
        // Extract text between <text> tags
        var texts: [String] = []
        let pattern = "<text[^>]*>([^<]+)</text>"
        if let regex = try? NSRegularExpression(pattern: pattern, options: []) {
            let matches = regex.matches(in: xmlString, options: [], range: NSRange(xmlString.startIndex..., in: xmlString))
            for match in matches {
                if let range = Range(match.range(at: 1), in: xmlString) {
                    var text = String(xmlString[range])
                    // Decode HTML entities
                    text = text.replacingOccurrences(of: "&amp;", with: "&")
                    text = text.replacingOccurrences(of: "&lt;", with: "<")
                    text = text.replacingOccurrences(of: "&gt;", with: ">")
                    text = text.replacingOccurrences(of: "&quot;", with: "\"")
                    text = text.replacingOccurrences(of: "&#39;", with: "'")
                    text = text.replacingOccurrences(of: "&apos;", with: "'")
                    texts.append(text)
                }
            }
        }
        
        let result = texts.joined(separator: " ")
            .replacingOccurrences(of: "\n", with: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        return result.isEmpty ? nil : result
    }
}

// Prevent retain cycle
private class LeakAvoider: NSObject, WKScriptMessageHandler {
    weak var delegate: WKScriptMessageHandler?
    
    init(delegate: WKScriptMessageHandler) {
        self.delegate = delegate
        super.init()
    }
    
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        delegate?.userContentController(userContentController, didReceive: message)
    }
}
