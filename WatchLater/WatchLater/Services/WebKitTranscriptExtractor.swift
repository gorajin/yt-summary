import Foundation
import WebKit

/// WebKit-based transcript extractor that uses WKWebView to run YouTube's JavaScript
/// This generates the POT token dynamically, which is required for caption access.
///
/// **Why this is necessary:**
/// YouTube's `baseUrl` in `captionTracks` returns 0 bytes without a `pot` token.
/// The `pot` token is generated by YouTube's botguard JavaScript - it cannot be scraped.
/// We must load the page in a real browser context and intercept the actual caption request.
@MainActor
class WebKitTranscriptExtractor: NSObject, WKNavigationDelegate {
    
    private var webView: WKWebView?
    private var continuation: CheckedContinuation<String?, Never>?
    private var videoId: String = ""
    
    /// Extract transcript using WKWebView to execute YouTube's JavaScript
    func extractTranscript(videoId: String) async -> String? {
        self.videoId = videoId
        
        print("ðŸ“± WebKit: Starting extraction for \(videoId)")
        
        return await withCheckedContinuation { continuation in
            self.continuation = continuation
            setupWebView()
            loadYouTubePage()
        }
    }
    
    private func setupWebView() {
        let config = WKWebViewConfiguration()
        config.allowsInlineMediaPlayback = true
        config.mediaTypesRequiringUserActionForPlayback = []
        
        // Inject script to intercept caption requests
        let interceptScript = WKUserScript(
            source: captionInterceptScript(),
            injectionTime: .atDocumentStart,
            forMainFrameOnly: false
        )
        config.userContentController.addUserScript(interceptScript)
        
        // Handle messages from JS
        config.userContentController.add(LeakAvoider(delegate: self), name: "captionHandler")
        
        webView = WKWebView(frame: .zero, configuration: config)
        webView?.navigationDelegate = self
        
        // Set mobile user agent
        webView?.customUserAgent = "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1"
    }
    
    private func loadYouTubePage() {
        guard let url = URL(string: "https://www.youtube.com/watch?v=\(videoId)") else {
            finishWithResult(nil)
            return
        }
        webView?.load(URLRequest(url: url))
    }
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        print("ðŸ“± WebKit: Page loaded, triggering caption extraction...")
        
        // Wait a bit for YouTube to initialize, then trigger caption extraction
        Task {
            try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
            await triggerCaptionExtraction()
        }
    }
    
    private func triggerCaptionExtraction() async {
        // This JavaScript will:
        // 1. Try to get captions from ytInitialPlayerResponse
        // 2. Click the CC button to trigger botguard
        // 3. Wait for the caption request and capture it
        let extractionScript = """
        (async () => {
            // First, try to directly fetch the captions with the player's context
            const player = document.querySelector('#movie_player');
            if (!player) {
                window.webkit.messageHandlers.captionHandler.postMessage({error: 'No player found'});
                return;
            }
            
            // Check current caption state and get tracks
            if (window.ytInitialPlayerResponse && window.ytInitialPlayerResponse.captions) {
                const tracks = window.ytInitialPlayerResponse.captions.playerCaptionsTracklistRenderer.captionTracks;
                if (tracks && tracks.length > 0) {
                    const track = tracks[0];
                    
                    // Intercept XMLHttpRequest to capture the actual caption request
                    let capturedUrl = null;
                    const originalOpen = XMLHttpRequest.prototype.open;
                    XMLHttpRequest.prototype.open = function() {
                        if (arguments[1] && arguments[1].includes('timedtext') && arguments[1].includes('pot=')) {
                            capturedUrl = arguments[1];
                        }
                        return originalOpen.apply(this, arguments);
                    };
                    
                    // Click CC button to trigger caption loading
                    const ccButton = document.querySelector('.ytp-subtitles-button');
                    if (ccButton) {
                        ccButton.click();
                        
                        // Wait for request to be made
                        await new Promise(r => setTimeout(r, 2000));
                        
                        if (capturedUrl) {
                            // Fetch the actual transcript
                            try {
                                const resp = await fetch(capturedUrl);
                                const text = await resp.text();
                                if (text.length > 0) {
                                    window.webkit.messageHandlers.captionHandler.postMessage({
                                        success: true, 
                                        transcript: text,
                                        url: capturedUrl
                                    });
                                    return;
                                }
                            } catch(e) {}
                        }
                    }
                }
            }
            
            window.webkit.messageHandlers.captionHandler.postMessage({error: 'Could not extract captions'});
        })();
        """
        
        webView?.evaluateJavaScript(extractionScript) { _, error in
            if let error = error {
                print("ðŸ“± WebKit: JS error: \(error)")
                // Timeout fallback
                Task {
                    try? await Task.sleep(nanoseconds: 5_000_000_000)
                    self.finishWithResult(nil)
                }
            }
        }
    }
    
    private func finishWithResult(_ result: String?) {
        if let cont = continuation {
            continuation = nil
            cont.resume(returning: result)
        }
        cleanup()
    }
    
    private func cleanup() {
        webView?.stopLoading()
        webView?.configuration.userContentController.removeScriptMessageHandler(forName: "captionHandler")
        webView = nil
    }
    
    private func captionInterceptScript() -> String {
        // Inject early to intercept network requests
        return """
        // Early injection to monitor requests
        (function() {
            const originalFetch = window.fetch;
            window.fetch = function() {
                const url = arguments[0];
                if (typeof url === 'string' && url.includes('timedtext') && url.includes('pot=')) {
                    console.log('WKIntercept: Found caption URL with pot');
                }
                return originalFetch.apply(this, arguments);
            };
        })();
        """
    }
}

// Handle script messages
extension WebKitTranscriptExtractor: WKScriptMessageHandler {
    nonisolated func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        Task { @MainActor in
            guard let body = message.body as? [String: Any] else {
                finishWithResult(nil)
                return
            }
            
            if let transcript = body["transcript"] as? String, !transcript.isEmpty {
                print("ðŸ“± WebKit: SUCCESS - Got \(transcript.count) chars")
                finishWithResult(parseTranscript(transcript))
            } else if let error = body["error"] as? String {
                print("ðŸ“± WebKit: Error - \(error)")
                finishWithResult(nil)
            } else {
                finishWithResult(nil)
            }
        }
    }
    
    private func parseTranscript(_ jsonString: String) -> String? {
        // Parse JSON3 format transcript
        guard let data = jsonString.data(using: .utf8) else { return nil }
        
        do {
            if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
               let events = json["events"] as? [[String: Any]] {
                var texts: [String] = []
                for event in events {
                    if let segs = event["segs"] as? [[String: Any]] {
                        for seg in segs {
                            if let utf8 = seg["utf8"] as? String {
                                texts.append(utf8)
                            }
                        }
                    }
                }
                let result = texts.joined(separator: " ")
                    .replacingOccurrences(of: "\n", with: " ")
                    .replacingOccurrences(of: "  ", with: " ")
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                return result.isEmpty ? nil : result
            }
        } catch {
            print("ðŸ“± WebKit: Parse error: \(error)")
        }
        return nil
    }
}

// Prevent retain cycle
private class LeakAvoider: NSObject, WKScriptMessageHandler {
    weak var delegate: WKScriptMessageHandler?
    
    init(delegate: WKScriptMessageHandler) {
        self.delegate = delegate
        super.init()
    }
    
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        delegate?.userContentController(userContentController, didReceive: message)
    }
}
