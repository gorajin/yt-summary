import Foundation
import WebKit

/// WebKit-based transcript extractor that uses WKWebView to run YouTube's JavaScript
/// This generates the POT token dynamically, which is required for caption access.
///
/// **Why this is necessary:**
/// YouTube's `baseUrl` in `captionTracks` returns 0 bytes without a `pot` token.
/// The `pot` token is generated by YouTube's botguard JavaScript - it cannot be scraped.
/// We must load the page in a real browser context and intercept the actual caption request.
@MainActor
class WebKitTranscriptExtractor: NSObject, WKNavigationDelegate {
    
    private var webView: WKWebView?
    private var continuation: CheckedContinuation<String?, Never>?
    private var videoId: String = ""
    
    /// Extract transcript using WKWebView to execute YouTube's JavaScript
    func extractTranscript(videoId: String) async -> String? {
        self.videoId = videoId
        
        print("ðŸ“± WebKit: Starting extraction for \(videoId)")
        
        return await withCheckedContinuation { continuation in
            self.continuation = continuation
            setupWebView()
            loadYouTubePage()
        }
    }
    
    private func setupWebView() {
        let config = WKWebViewConfiguration()
        config.allowsInlineMediaPlayback = true
        config.mediaTypesRequiringUserActionForPlayback = []
        
        // Inject script to intercept caption requests
        let interceptScript = WKUserScript(
            source: captionInterceptScript(),
            injectionTime: .atDocumentStart,
            forMainFrameOnly: false
        )
        config.userContentController.addUserScript(interceptScript)
        
        // Handle messages from JS
        config.userContentController.add(LeakAvoider(delegate: self), name: "captionHandler")
        
        webView = WKWebView(frame: .zero, configuration: config)
        webView?.navigationDelegate = self
        
        // Set mobile user agent
        webView?.customUserAgent = "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1"
    }
    
    private func loadYouTubePage() {
        guard let url = URL(string: "https://www.youtube.com/watch?v=\(videoId)") else {
            finishWithResult(nil)
            return
        }
        webView?.load(URLRequest(url: url))
    }
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        print("ðŸ“± WebKit: Page loaded, triggering caption extraction...")
        
        // Wait a bit for YouTube to initialize, then trigger caption extraction
        Task {
            try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
            await triggerCaptionExtraction()
        }
    }
    
    private func triggerCaptionExtraction() async {
        // This JavaScript extracts captions from the YouTube page.
        // We use a simpler synchronous approach to avoid "unsupported type" errors.
        // The script will:
        // 1. Get ytInitialPlayerResponse from the page
        // 2. Find caption tracks
        // 3. Return the caption URL for us to fetch in Swift
        let extractionScript = """
        (function() {
            // Get the player response (contains caption URLs)
            var playerResponse = window.ytInitialPlayerResponse;
            if (!playerResponse) {
                // Try getting from ytplayer.config
                try {
                    if (window.ytplayer && window.ytplayer.config && window.ytplayer.config.args) {
                        var args = window.ytplayer.config.args;
                        if (args.player_response) {
                            playerResponse = JSON.parse(args.player_response);
                        }
                    }
                } catch(e) {}
            }
            
            if (!playerResponse) {
                window.webkit.messageHandlers.captionHandler.postMessage({error: 'No player response found'});
                return null;
            }
            
            // Check for captions
            var captions = playerResponse.captions;
            if (!captions || !captions.playerCaptionsTracklistRenderer) {
                window.webkit.messageHandlers.captionHandler.postMessage({error: 'No captions available'});
                return null;
            }
            
            var tracks = captions.playerCaptionsTracklistRenderer.captionTracks;
            if (!tracks || tracks.length === 0) {
                window.webkit.messageHandlers.captionHandler.postMessage({error: 'No caption tracks'});
                return null;
            }
            
            // Get the first English or any track
            var track = null;
            for (var i = 0; i < tracks.length; i++) {
                if (tracks[i].languageCode === 'en' || tracks[i].languageCode.startsWith('en')) {
                    track = tracks[i];
                    break;
                }
            }
            if (!track) track = tracks[0];
            
            var baseUrl = track.baseUrl;
            if (!baseUrl) {
                window.webkit.messageHandlers.captionHandler.postMessage({error: 'No caption URL'});
                return null;
            }
            
            // Return caption URL for Swift to fetch
            window.webkit.messageHandlers.captionHandler.postMessage({
                captionUrl: baseUrl,
                language: track.languageCode
            });
            return null;
        })();
        """
        
        webView?.evaluateJavaScript(extractionScript) { [weak self] _, error in
            if let error = error {
                print("ðŸ“± WebKit: JS error: \(error)")
                // Give message handler time to fire, or timeout
                Task {
                    try? await Task.sleep(nanoseconds: 3_000_000_000)
                    self?.finishWithResult(nil)
                }
            }
        }
    }
    
    private func finishWithResult(_ result: String?) {
        if let cont = continuation {
            continuation = nil
            cont.resume(returning: result)
        }
        cleanup()
    }
    
    private func cleanup() {
        webView?.stopLoading()
        webView?.configuration.userContentController.removeScriptMessageHandler(forName: "captionHandler")
        webView = nil
    }
    
    private func captionInterceptScript() -> String {
        // Inject early to intercept network requests
        return """
        // Early injection to monitor requests
        (function() {
            const originalFetch = window.fetch;
            window.fetch = function() {
                const url = arguments[0];
                if (typeof url === 'string' && url.includes('timedtext') && url.includes('pot=')) {
                    console.log('WKIntercept: Found caption URL with pot');
                }
                return originalFetch.apply(this, arguments);
            };
        })();
        """
    }
}

// Handle script messages
extension WebKitTranscriptExtractor: WKScriptMessageHandler {
    nonisolated func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        Task { @MainActor in
            guard let body = message.body as? [String: Any] else {
                finishWithResult(nil)
                return
            }
            
            // Case 1: Got a caption URL - fetch it using the WebView
            if let captionUrl = body["captionUrl"] as? String {
                let language = body["language"] as? String ?? "unknown"
                print("ðŸ“± WebKit: Got caption URL for \(language), fetching...")
                await fetchCaptionFromWebView(urlString: captionUrl)
                return
            }
            
            // Case 2: Got direct transcript (from older approach or direct extraction)
            if let transcript = body["transcript"] as? String, !transcript.isEmpty {
                print("ðŸ“± WebKit: SUCCESS - Got \(transcript.count) chars")
                finishWithResult(parseTranscript(transcript))
                return
            }
            
            // Case 3: Error
            if let error = body["error"] as? String {
                print("ðŸ“± WebKit: Error - \(error)")
                finishWithResult(nil)
                return
            }
            
            finishWithResult(nil)
        }
    }
    
    /// Fetch caption data using WebView's fetch (has proper session/cookies)
    @MainActor
    private func fetchCaptionFromWebView(urlString: String) async {
        // Escape the URL for JavaScript
        let escapedUrl = urlString.replacingOccurrences(of: "'", with: "\\'")
        
        // Add json3 format if not present
        var fetchUrl = escapedUrl
        if !fetchUrl.contains("fmt=") {
            fetchUrl += "&fmt=json3"
        }
        
        let fetchScript = """
        (function() {
            fetch('\(fetchUrl)')
                .then(function(response) { return response.text(); })
                .then(function(text) {
                    if (text && text.length > 0) {
                        window.webkit.messageHandlers.captionHandler.postMessage({
                            transcript: text
                        });
                    } else {
                        window.webkit.messageHandlers.captionHandler.postMessage({
                            error: 'Empty response'
                        });
                    }
                })
                .catch(function(err) {
                    window.webkit.messageHandlers.captionHandler.postMessage({
                        error: 'Fetch failed: ' + err.message
                    });
                });
            return null;
        })();
        """
        
        webView?.evaluateJavaScript(fetchScript) { [weak self] _, error in
            if let error = error {
                print("ðŸ“± WebKit: Fetch JS error: \(error)")
                Task {
                    try? await Task.sleep(nanoseconds: 3_000_000_000)
                    self?.finishWithResult(nil)
                }
            }
        }
    }
    
    private func parseTranscript(_ jsonString: String) -> String? {
        // Parse JSON3 format transcript
        guard let data = jsonString.data(using: .utf8) else { return nil }
        
        do {
            if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
               let events = json["events"] as? [[String: Any]] {
                var texts: [String] = []
                for event in events {
                    if let segs = event["segs"] as? [[String: Any]] {
                        for seg in segs {
                            if let utf8 = seg["utf8"] as? String {
                                texts.append(utf8)
                            }
                        }
                    }
                }
                let result = texts.joined(separator: " ")
                    .replacingOccurrences(of: "\n", with: " ")
                    .replacingOccurrences(of: "  ", with: " ")
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                return result.isEmpty ? nil : result
            }
        } catch {
            print("ðŸ“± WebKit: Parse error: \(error)")
        }
        return nil
    }
}

// Prevent retain cycle
private class LeakAvoider: NSObject, WKScriptMessageHandler {
    weak var delegate: WKScriptMessageHandler?
    
    init(delegate: WKScriptMessageHandler) {
        self.delegate = delegate
        super.init()
    }
    
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        delegate?.userContentController(userContentController, didReceive: message)
    }
}
